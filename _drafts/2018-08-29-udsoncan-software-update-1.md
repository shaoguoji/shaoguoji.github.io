---
layout:          post
title:           CAN 诊断升级那点事儿（一） 
subtitle:        嵌入式软件更新方法，IAP 方式烧录的实现
date:            2018-08-29 22:26:39 +0800
author:          Shao Guoji
header-img:      
catalog:         true
tag:
    - 嵌入式
    - 汽车电子
---

### 关于本系列

入职不久后被安排编写产品的诊断升级上位机，于是疯狂啃各种协议、标准，车厂文档，加上自己的一些思考，也算粗糙做出来了。“项目驱动型”的学习加深了自己对 IAP 升级流程的理解，以及 UDS 诊断在 FlashBootLoader 中的应用，决定写点东西整理、分享当中的来龙去脉，便有了“CAN 诊断升级那点事儿”系列的 3 篇文章，包括：

* [](CAN 诊断升级那点事儿（一）—— 嵌入式软件的更新方法)：介绍嵌入式软件升级基本原理与知识
* [](CAN 诊断升级那点事儿（二）—— CAN 总线与 UDS 协议)：了解车载通讯协议与 UDS 基本服务（还没写~~~）
* [](CAN 诊断升级那点事儿（三）—— Flash BootLoader 流程)：结合实例分析软件烧写具体流程（还没写~~~）

文章主要内容围绕 CAN 诊断升级展开 —— 简单来说，是在 CAN 总线的基础上，基于 UDS 诊断协议，从 PC 端把固件数据传输给 ECU 并烧写到内部 Flash……说人话！！！好吧，其实就是给汽车的某个部件“刷机”。

#### 一些术语

* 上位机：给设备发送指令与数据的控制程序，通常运行在 PC 端，同时与单片机通讯。
* ECU(Electronic Control Unit)：电子控制单元。这里看作汽车上的 MCU（单片机）即可。
* CAN(Controller Area Network)：控制器局域网络。定义了网络通讯的物理层电气特性与链路层帧结构。
* UDS(Unified Diagnostic Services)：统一诊断服务。应用层协议，采用请求响应机制，可实现汽车诊断、数据传输功能。
* IAP(In Application Programming)：在应用编程。“编程”指的是程序数据烧录，可在程序运行期间完成此操作。代码分为 BootLoader 和 App 两部分。
* Flash：嵌入式设备的“硬盘”，程序安身之处，大多位于芯片内部。
* 烧录/烧写：将编译后的二进制可执行程序放到 Flash 中的过程。
* 更新/升级：用新的固件替换原有的旧固件。

*注：上述术语说明并不严谨，而是侧重于有助理解文章的通俗解释。*

---

### 不安分的固件

在过去，嵌入式软件通常被固化存储器中，烧录后几乎不会改动，因此被称为固件（firmware）。但随着功能复杂程度的提升，固件往往需要频繁迭代更新，存储器从 ROM 发展到 Flash，固件的刷写方式也不停更新换代，从 ISP、IAP，再到现在普遍使用的 OTA 升级，固件被反复修改烧录，开始不安分起来、慢慢变得没那么固定了。

#### 几种烧录方式的理解

一种很好的思维方式是，使用“源/目标模型（Source/Target Models）”进行抽象理解，这对嵌入式底层原理十分管用。所谓“源/目标模型”，指数据的来龙去脉 —— 从哪来？到哪去？为实现数据的流动，需满足什么条件？要实现那些接口？如果在脑海中对这些问题有清晰的认识，会更容易理解一些常见流程。

让我们从 Source/Target 的角度来理解常见的烧录方式：固件字节流通过 MCU 写入 Flash，对 MCU 来说，数据的来源便是 MCU 与外部的数据接口，这些接口可以是 UART、I2C、SPI、JTAG 等等。注意，这里的接口有两层含义，一是指规定高低电平如何变换的“规范”，二是实现这些规范的软硬件（即同样的信号可以通过软件或硬件产生）。

把数据“来龙”弄清楚了，“去脉”其实更显而易见。固件的最终归宿是内部存储器（Flash），同理，要想将固件写入 Falsh，也必须为 MCU 提供读写 Flash 的能力（接口），这样一来事情就简单多了。综上所述，要想把固件烧录到 Falsh 中，需满足以下两个条件：

1. 接收外部数据的 MCU 通信接口（来龙）
2. 操纵 Flash 的存储器读写接口（去脉）

只要打通了数据的“来路”与“去路”，完成刷写、更新程序工作便顺理成章，所有的烧录方法都在干这两件事，不同的是实现方式不同。

#### ISP 和 IAP 

对 ISP 下载而言（常见于 51 和 STM32 单片机），上述两个条件均由芯片内部实现 —— 芯片厂商预置了一段 Boot 程序，固化在单片机内部某个独立位置，完成固件数据的接收与 Flash 写入操作。ISP 烧录一般使用串口和 MCU 通信，并且只能使用固定管脚传输和触发。由于所有东西都是出厂预设固化，程序员丝毫无法干预，颇具“硬件实现”的特点。

而 IAP 就比较厉害了，它以“纯软件”方式实现数据的接收与 Flash 读写，所有底层流程、数据都把玩于软件开发者股掌之中。具体来说，可以选择任一途径接收固件，无论是 UART、I2C、CAN，还是 WiFi、蓝牙、红外线……只要实现了软件接口驱动，能从中读到数据，程序就能进行进一步的处理。

另外，程序对数据的去向更是可以精确控制，放哪里？怎么放？什么时候放？直接写入还先是加工一下？这时，程序员就需要进一步了解关于 Falsh 的细节，要考虑的事情也更多（但我一直认为，知道的越多，可玩性越高，Know it then hack it）。

ISP 就像是芯片厂商提供的黑盒子，帮我们完成了所有工作，拿来即用、坚固稳定，然而“一手包办”的同时伴随着死板、不够灵活的缺点。IAP 流程中所有步骤都亲力亲为，虽然细节繁琐，但却能针对不同的场景与功能需求，采用不同的数据链路与协议，开发出一套专用的升级刷写系统。

---

### IAP 升级系统的设计



#### 整体结构

#### BootLoader

#### APP

---



